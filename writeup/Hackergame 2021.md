## Hackergame 2021

### 签到

把 get 参数改成时间戳。



### 进制十六--参上

ocr + hex



### 去吧！追寻自由的电波

放慢到 0.5 倍速直接听就好了，要了解一下无线电波如何表示字母



### 透明的文件

[ANSI escape code/sequence](https://blog.csdn.net/lano2088/article/details/51985563)，所有的左中括号前都应该有 escape 转义符号，replace("[", "\x1b[")，放进 linux 里 echo 或者 python print 一下，选中之后反色，就能看到五颜六色的 flag 了。



### 旅行照片

搜索一下蓝色的 KFC，发现是秦皇岛新澳海洋世界海豚馆旁边的，配合百度街景得到方位，观察影子方向得到时间，大众点评得到电话，最后爆破一下楼层。



### FLAG 助力大红包

对 ip 的前后端检查：后端检查可以修改 POST 参数，前端可以用 XFF 绕过，不同的 /8 网段只需要遍历 ip 地址第一个字节，每隔 1s 发一次请求，遍历 256 次即可得到 flag。

```python
for i in range(256):
    print("{}.1.1.1".format(str(i)))
```



### Amnesia

#### 轻度失忆

.data 和 .rodata 会被清除，但 .bss 不会，所以设置一个初始化为 0 的全局变量，然后一个个输出字符就好了。（不过后来想了想，感觉好像不需要 x，直接输出对应的 ascii 也是可行的，但懒得尝试了）

```c
#include<stdio.h>
int x = 0;
int main() {
    printf("%c", x + 72);
    printf("%c", x + 101);
    printf("%c", x + 108);
    printf("%c", x + 108);
    printf("%c", x + 111);
    printf("%c", x + 44);
    printf("%c", x + 32);
    printf("%c", x + 119);
    printf("%c", x + 111);
    printf("%c", x + 114);
    printf("%c", x + 108);
    printf("%c", x + 100);
    printf("%c", x + 33);
    return 0;
}
```



### EASY RSA

算 p 用到了威尔逊定理：p 是素数，当且仅当 `(p - 1)! ≡ -1 (mod p)`。推得 `(y!) ≡ -k^-1 (mod x)`，其中 `k = (y + 1)(y + 2)...(x - 1)`。

算 q：先根据 value[-1] 求出整个 value 数组，因为不知道怎么求 prevprime，所以选择了直接从前往后扫 2333。n 就是 value[i] 的乘积，phi 即 (value[i] - 1) 的乘积，RSA 解密得到 q。

得到 p 和 q 之后就可以愉快地解开明文了！最后把 m hex to str 就好啦！

```python
import gmpy2
import sympy
from Crypto.Util.number import *
import binascii

x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451
y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439
e = 65537

# 算 p
k = 1
for i in range(y + 1, x):
    k = (k * i) % x
k_inv = (-gmpy2.invert(k, x)) % x
p = sympy.nextprime(k_inv)
print("p = ", p)

def get_q():
    value = [getPrime(256)]
    for i in range(1, 10):
        value.append(sympy.nextprime(value[i - 1]))
    print("value[-1] = ", value[-1])
    # value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967
    n = 1
    for i in range(10):
        n = n * value[i]
    q = getPrime(512)
    value_q = pow(q, e, n)
    print("value_q = ", value_q)
    # value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819
    return sympy.nextprime(q)

# 查 value[-1] 前十个素数
# i = 80096058210213458444437404275177554701604739094679033012396452382975889805967
# while i != 80096058210213458444437404275177554701604739094679033012396452382975889905967:
#     i = sympy.nextprime(i)
#     print(i)

# 生成 value
value = [80096058210213458444437404275177554701604739094679033012396452382975889905121]
for i in range(1, 10):
    value.append(sympy.nextprime(value[i - 1]))
print("value[-1] = ", value[-1])

n = 1
phi = 1
for i in range(10):
    n = n * value[i]
    phi *= (value[i] - 1)
print("n = ", n)
print("phi = ", phi)

# 解 q
value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819
d = gmpy2.invert(e, phi)
q = pow(value_q, d, n)
q = sympy.nextprime(q)
print("q = ", q)

# 解明文
n = p * q
phi = (p - 1) * (q - 1)
d = gmpy2.invert(e, phi)
c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478
m = pow(c, d, n)
print(hex(m))
```



### 赛博厨房

#### Level 0

观察发现只有 01 10 00 11 四种情况，所以写四个代码，看到哪个跑那个，所有代码都是一个套路，改一下参数就行。

```
11
向右 2 步
拿起 1 个物品
向下 1 步
向左 2 步
放下 1 个物品
向右 2 步
向上 1 步
拿起 1 个物品
向下 1 步
向左 2 步
放下 1 个物品
```

#### Level 2

一个循环。

```
向右 1 步
拿起 73 个物品
向下 1 步
向左 1 步
放下 1 个物品
如果手上的物品大于等于 0 向上跳转 1 行
```

